<?php
//数据库缓存优化
/**
 * 相关概念
 *      什么是数据库缓存
 *      为什么要使用缓存
 *      使用MySQL查询缓存
 *      使用Memcache缓存
 *      使用Redis缓存
 *
 *  什么是数据库缓存
 *      MySQL等一些常见的关系型数据库的数据都存储在磁盘当中，在高并发场景下，业务应用对MySQL
 *      产生的增、删、改、查的操作造成巨大的I/O开销和查询压力，这无疑对数据库的服务器都是一种
 *      巨大的压力，为了解决此类问题，缓存数据的概念应运而生。
 *
 *      极大地解决数据库服务器的压力
 *      提高应用数据的响应速度
 *
 *      常见的缓存形式：内存缓存，文件缓存
 *      我们本节重点讨论内存缓存
 *
 *  为什么要使用缓存
 *      缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大
 *      程度地降低对数据库副武器的访问压力。
 *
 *      用户请求-->数据查询-->连接数据库服务器并查询数据
 *      -->将数据缓存起来(HTML、内存、JSON、序列化数据)-->显示给客户端
 *
 *      用户再次请求或者新用户访问-->数据查询-->直接从缓存中获取数据-->显示给客户端
 *
 *  缓存需要考虑的内容
 *      缓存方式的选择
 *      缓存场景的选择
 *      缓存数据的实时性
 *      缓存数据的稳定性
 *
 *  MySQL的查询缓存
 *      启用MySQL查询缓存
 *      极大地降低CPU使用率
 *
 *      query_cache_type
 *      查询缓存类型，有0,1,2三个取值。0则不使用查询缓存。1表示始终使用查询缓存。
 *      2表示按需使用查询缓存。
 *
 *      query_cache_type为1时，亦可关闭查询缓存
 *      SELECT SQL_NO_CACHE * FROM my_table WHERE condition;
 *
 *      query_cache_type 为2时，可按需使用查询缓存
 *      SELECT SQL_CACHE * FROM my_table WHERE condition;
 *
 *      query_cache_size
 *      默认情况下query_cache_size为0，表示为查询缓存预留的内存为0，则无法使用查询缓存。
 *      SET GLOBAL query_cache_size = 134217728;
 *
 *      查询缓存可以看做是SQL文本和查询结果的映射
 *      第二次查询的SQL和第一次查询的SQL完全相同，则会使用缓存
 *      SHOW STATUS LIKE 'Qcache_hits';查看命中次数
 *      表的结构或数据发生改变时，查询缓存中的数据不再有效
 *
 *      清理缓存
 *      FLUSH QUERY CACHE; //清理查询缓存内存碎片
 *      RESET QUERY CACHE; //从查询缓存中移出所有查询
 *      FLUSH TABLES;//关闭所有打开的表，同时该操作将会清空查询缓存中的内容
 *
 *
 * 使用Memcache缓存查询数据
 *      对于大型站点，如果没有中间缓存层，当流量打入数据库层时，即便有之前的几层为我们
 *      挡住一部分流量，但是在大并发的情况下，还是会有大量请求涌入数据库层，
 *      这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。
 *
 *      memcache是一套分布式的高速缓存系统，有LiveJournal的BradFitzptrick开发，但目前
 *      被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的
 *      网站速度提升效果十分显著。
 *
 *      工作原理
 *          Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个巨大
 *          的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库
 *          检索的结果等。简单的说就是将数据调用到内存，然后从内存中读取，从而大大提高
 *          读取速度。
 *
 *      工作流程
 *          先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对
 *          数据库进行任何操作；如果请求的数据不再memcached中，就去查数据库，把从数据
 *          库中获取的数据返回给客户端，同时把数据缓存一份到memcached中
 *
 *      方法
 *          获取：get(key)
 *          设置：set(key,val,expire)
 *          删除：delete(key)
 *
 *      通用缓存机制
 *          用查询的方法名+参数作为查询时的key value 对中的key值
 *
 * 使用redis缓存查询数据
 *      与Memcache的区别
 *          性能相差不大
 *          Redis在2.0版本后增加了自己的VM特性，突破物理内存的限制，Memcache可以修改最大可有内存，采用LRU算法。
 *          Redis，依赖客户端来实现分布式读写
 *          Memcache本身没有数据冗余机制
 *          Redis支持(快照、AOF)，依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响。
 *          Memcache不支持持久化，通常做缓存，提升性能；
 *          Memcache在并发场景下，用cas保证一致性，redis事务支持比较弱，只能保证事务中的每个操作连续执行。
 *          Redis支持多种类的数据类型
 *          Redis用于数据量较小的高性能操作和运算上
 *          Memcache用于动态系统中减少数据库负载，提升性能；适合做缓存，提升性能。
 *
 *      缓存其他数据
 *          Session
 *          session_set_saves_handler
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */





