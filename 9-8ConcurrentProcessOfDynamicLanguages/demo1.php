<?php
//动态语言的并发处理
/**
 * 相关概念
 *      什么是进程、线程、协程
 *      什么是多进程、多线程
 *      同步阻塞模型
 *      异步非阻塞模型
 *      PHP并发编程实践
 *
 * 什么是进程、线程、协程
 *      进程(Process)是计算机中的程序关于某数据集合的一次运行活动，是
 *      系统进行资源分配和调度的基本单位，是操作系统结构的基础。
 *      进程是一个"执行中的从程序"
 *
 *      进程的三态模型：多道程序系统中，进程在处理器上交替运行，状态不断地发生变化
 *      运行、就绪、阻塞
 *
 *      运行： 当一个进程在处理机上运行时，则称该进程处于运行状态。
 *      处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程
 *      只有一个。在没有其他进程可以执行时(如所有进程都在阻塞状态),通常会自动执行系统的空闲进程。
 *
 *      就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称
 *            此进程处于就绪状态。
 *      就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状
 *      态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。
 *
 *      阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生(例如请求I/O而等待I/O完成等)
 *            而暂时停止运行，这时即使把处理机分配给进程也无法运行，顾称该进程处于阻塞状态。
 *
 *
 *      进程的五态模型：对于一个实际的系统，进程的状态及其转换更为复杂
 *      新建态、活跃就绪/静止就绪、运行、活跃阻塞/静止阻塞、终止态
 *
 *      新建态：对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息
 *
 *      终止态：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中手机有关信息
 *
 *      活跃就绪：是指进程在主存(即主内存)并且可被调度的状态。
 *
 *      静止就绪(挂起就绪): 是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有
 *              当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把
 *              挂起就绪态进程调回主存并转换为活跃就绪。
 *
 *      活跃阻塞：是指进程已在主存，一旦等待的事件产生便进入活跃就绪状态。
 *
 *      静止阻塞：进程对换到辅存时的阻塞状态，一旦等待的事件产生便进入静止就绪状态。
 *
 *
 *
 *      由于用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销
 *      方面或是响应用户请求的效率方面来看。因此操作系统中线程的概念便被引进了。
 *
 *      线程，有时被称为轻量级进程(Lightweight Process，LWP)，是程序执行流的最小单元。
 *
 *      线程是进程中的一个实体，是被系统独立调度和分派的基本单位，
 *      线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源
 *      但它可与同属一个进程的其他线程共享进程所拥有的全部资源。
 *
 *      一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
 *
 *      线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，
 *      是系统独立调度和分派CPU的基本单位指运行中的程序的调度单元。
 *      在单个程序中同时运行多个线程完成不同的工作，称为多线程。
 *
 *      每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。
 *
 *      线程的状态：就绪、阻塞、运行
 *
 *      就绪状态：线程具备运行的所有条件，逻辑上可以运行，在等待处理机。
 *      运行状态：线程占有处理机正在运行。
 *      阻塞状态：线程在等待一个事件(如某个信号量),逻辑上不可执行。
 *
 *      协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器
 *      上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，
 *      恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁
 *      的访问全局变量，所以上下文的切换非常快。
 *
 *
 * 线程与进程的区别
 *      1.线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，
 *        而进程有自己独立的地址空间。
 *      2.进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源
 *      3.线程是处理器调度的基本单位，但进程不是。
 *      4.两者均可并发执行。
 *      5.每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够
 *        独立运行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
 *
 * 线程和协程的区别
 *      1.一个线程可以多个协程，一个进程也可以单独拥有多个协程
 *      2.线程进程都是同步机制，而协程是异步
 *      3.协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
 *
 * 什么是多进程、多线程
 *      多进程
 *          同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这就是多进程。
 *          边看慕课网视频，边使用WebIDE
 *          多开一个进程，多分配一份资源，进程间通讯不方便。
 *
 *      多线程
 *          线程就是把一个进程分为很多片，每一片都可以是一个独立的流程
 *          与多进程的区别是只会使用一份进程的资源，线程间可以直接通信
 *
 * 多个概念之间的区别
 *      例子
 *          单进程单线程：一个人在一个桌子上吃菜
 *          单进程多线程：多个人在同一个桌子上一起吃菜
 *          多进程单线程：多个人每个人在自己的桌子上吃菜
 *
 * 同步阻塞
 *      多进程
 *          最早的服务器端程序都是通过多进程、多线程来解决并发I/O的问题
 *          一个请求创建一个进程，然后子进程进入循环同步堵塞地与客户端连接进行交互，收发处理数据。
 *
 *      多线程
 *          用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据
 *
 *      步骤
 *          创建一个socket
 *          进入while循环，阻塞在进程accept操作上，等待客户端连接进入
 *          主进程在多进程模型下通过fork创建子进程。
 *          多线程模式下可以创建子线程。
 *          子进程/线程创建成功后进入while循环，阻塞在recv调用上，等待客户端向服务器发送数据。
 *          收到数据后服务器程序进行处理然后使用send向客户端发送响应
 *          当客户端连接关闭时，子进程/线程退出并销毁所有资源。主进程/线程会回收掉此进程/线程。
 *
 *      缺点：
 *          这种模型严重依赖进程的数量解决并发问题
 *          启动大量进程会带来额外的进程调度消耗
 *
 * 异步非阻塞
 *      现在各种高并发异步IO的服务器程序都是基于epoll实现的
 *      IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，
 *      它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。
 *
 *      Reactor有4个核心的操作
 *      1.add添加socket监听到reactor
 *      2.set修改事件监听，可以设置监听的类型，如可读、可写
 *      3.del从reactor中移除，不再监听事件
 *      4.callback，事件发生后对应的处理逻辑，一般在add/set时制定
 *
 *      Nginx:多线程Reactor
 *      Swoole：多线程Reactor + 多进程Worker
 *
 *
 * PHP并发编程实践
 *      PHP的Swoole扩展
 *      消息队列
 *      接口的并发请求
 *
 *      PHP的Swoole扩展
 *          PHP的异步、并行、高性能网络通信引擎，使用纯C语言编写，提供了PHP语言的异步
 *          多线程服务器，异步TCP/UDP网络客户端，异步MySQL，异步Redius，数据库连接池，
 *          AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询
 *
 *          除了异步IO的支持之外，Swoole为PHP多进程的模式设计了多个并发数据结构和IPC通信机制，
 *          可以大大简化多进程并发编程的工作。
 *
 *          Swoole2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序。
 *
 *          Swoole的异步MySQL实现(如图 Swoole的异步MySQL实现)
 *
 *      消息队列
 *          场景说明：用户注册后，需要发注册邮件和注册短信
 *          串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。
 *          并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。
 *          消息队列：将注册信息写入数据库成功后，将成功信息写入队列，此时直接返回成功给用户，
 *                    写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信。
 *
 *          场景说明：用户下单后，订单系统需要通知库存系统
 *          假如库存系统无法访问，则订单库存将失败，从而导致订单失败，订单系统与
 *          库存系统耦合
 *
 *          应用解耦
 *              引用队列
 *                  用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
 *                  订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
 *
 *          流量削锋
 *              应用场景：秒杀活动，流量瞬时激增，服务器压力大。
 *              用户发起请求，服务器接收后，先写入消息队列。假如消息队列长
 *              度超过最大值，则直接报错或提示用户。
 *              后续程序读取消息队列再做处理。
 *
 *              控制请求量
 *              缓解高流量
 *
 *      日志处理
 *          应用场景：解决大量日志的传输
 *          日志采集程序将程序写入消息队列，然后通过日志处理程序的订阅消费日志。
 *
 *      消息通讯
 *          应用场景：聊天室
 *          多个客户端订阅同一主题，进行消息发布和接收
 *
 *      常见消息队列产品
 *          Kafka、ActiveMQ、ZeroMQ、RabbitMQ、Redis等
 *
 *      接口的并发请求
 *          curl_multi_init
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

